The problem for Advent of Code Day 16 is we are given a ticket with fields we can't understand and values for those fields:

e.g, An example ticket:

```
.--------------------------------------------------------.
| ????: 101    ?????: 102   ??????????: 103     ???: 104 |
|                                                        |
| ??: 301  ??: 302             ???????: 303      ??????? |
| ??: 401  ??: 402           ???? ????: 403    ????????? |
'--------------------------------------------------------'
```

And some rules for the fields on the ticket:

```
class: 0-1 or 4-19
row: 0-5 or 8-19
seat: 0-13 or 16-19
```

We also get given our ticket, and some nearby tickets:

```
your ticket:                                                                                             
11,12,13                                                                                                 
                                                                                                         
nearby tickets:                                                                                          
3,9,18                                                                                                   
15,1,5                                                                                                   
6,9,87                                                                                                   
5,14,9                                                                                                   
11,3,22  
```

We have to filter out invalid tickets, then use the remaining tickets to determine which fields is which in our ticket based on the rules.

For the example input the invalid tickets would be:                                                      

```
6,9,87                                                                                                   
11,3,22                                                                                                  
```                                                                                                      
That leaves:                                                                                             

```                                                                                                      
3,9,18                                                                                                   
15,1,5                                                                                                   
5,14,9   
```

From this we can determine the fields:

```
tickets  |   3  |   9  |  18   |                                                                         
         |  15  |   1  |   5   |                                                                         
         |   5  |  14  |   9   |                                                                         
         |---------------------|                                                                         
possible | row | row   | row   |                                                                         
fields   |     | class | class |                                                                         
         |     |       | seat  |  
```

So the first value in a ticket has to be "row"
The second value in a ticket has to be "class"
The third value in a ticket has to be "seat"

This logic needs implementing for the much larger actual puzzle input.    

# Parsing

This is just parsing the ranges and finding tickets that contain fields which can't be placed into any of the ranges.   

## Parsing the rules from the input

The first 20 lines of the input contain the rules.

```clojure
(defn read-input []                                                                                      
   (->> (slurp "resources/2020/day16")                                                                   
        (str/split-lines)))    

```

An example rule from the input:

"departure location: 26-715 or 727-972"

This can be regex'd out as `rule name`, `range1`, `range2`:

```clojure
(rest (re-find #"(.+): (\d+-\d+) or (\d+-\d+)" "departure location: 26-715 or 727-972"))
;=> ("departure location" "26-715" "727-972") 
```

So read 20 lines from the input and map this over them:

```clojure
(->> (read-input)
     (take 20)
     (map (fn [rule] (rest (re-find #"(.+): (\d+-\d+) or (\d+-\d+)" rule)))))
```
produces:

```
(("departure location" "26-715" "727-972")
 ("departure station" "45-164" "175-960")
 ("departure platform" "43-247" "270-972")
 ("departure track" "25-306" "330-949")
 ...
 ...
 ("zone" "34-521" "534-971"))
```
Now a function to parse those into integers:

```clojure
;input ("departure location" "26-715" "727-972")
;output ["departure location" [26 715] [727 972]]
(defn build-rule [[rule-name r1 r2]]
  (letfn [(parse-range [r]
            (let [[s e] (->> (str/split r #"-")
                             (map #(Integer/parseInt %)))]
              [s e]))]
    [rule-name (parse-range r1) (parse-range r2)]))
```

This function destructures the rule that was passed in, that rule being a collection with 3 items, into `rule-name`, `r1` and `r2`. It then defines a local function called `parse-range` and returns the rule as a vector of rule-name, rule1, rule2.

```clojure
(build-rule '("departure location" "26-715" "727-972"))
=> ["departure location" [26 715] [727 972]]
```

Adding this into the main parsing code:

```clojure
(->> (read-input)
     (take 20)
     (map (fn [rule] (rest (re-find #"(.+): (\d+-\d+) or (\d+-\d+)" rule))))
     (map build-rule))
```

Now make a function out of this called `build-rules`:

```clojure
(defn build-rules [input]
  (->> input
       (take 20)
       (map (fn [rule] (rest (re-find #"(.+): (\d+-\d+) or (\d+-\d+)" rule))))
       (map build-rule)))
```

And we have the rules parsed:

```
(["departure location" [26 715] [727 972]]
 ["departure station" [45 164] [175 960]]
 ["departure platform" [43 247] [270 972]]
 ["departure track" [25 306] [330 949]]
 ["departure date" [26 635] [660 961]]
 ["departure time" [42 773] [793 961]]
 ["arrival location" [28 928] [943 952]]
 ["arrival station" [36 593] [613 966]]
 ["arrival platform" [33 280] [297 951]]
 ["arrival track" [44 358] [371 974]]
 ["class" [39 815] [839 955]]
 ["duration" [39 573] [589 959]]
 ["price" [49 846] [865 962]]
 ["route" [30 913] [924 954]]
 ["row" [29 865] [890 965]]
 ["seat" [44 667] [683 969]]
 ["train" [32 473] [482 969]]
 ["type" [40 424] [432 953]]
 ["wagon" [49 156] [164 960]]
 ["zone" [34 521] [534 971]])
 ```
 
 Starting to build the final solution, we have the input and the rules parsed.
 
 ```clojure
 (defn solution []
    (let [input (read-input)
          rules (build-rules input)]
    ))
 
 ```
 
 ## Parsing nearby tickets
 
 Now to parse the nearby tickets. This is easy they are just a list of comma seperated integers that start on line 25.
 
 ```clojure
 (defn parse-nearby-tickets [input]
  (->> input
       (drop 25)
       (map #(->> (str/split % #",")
                  (map (fn [n] (Integer/parseInt n)))))))
 ```
 Produces:
 
 ```clojure
 (parse-nearby-tickets (read-input))
 =>
 ((279 705 188 357 892 488 741 247 572 176 760 306 410 861 507 906 179 501 808 245)
  (51 436 407 893 228 722 213 239 813 460 415 571 95 98 116 138 811 552 164 813)
  (407 242 909 340 99 906 566 749 880 708 273 843 737 244 244 461 903 198 806 64)
  (83 740 373 298 441 199 633 271 397 437 693 624 461 372 296 684 122 795 754 124)
  (294 541 629 865 767 632 434 189 86 799 891 667 466 707 419 197 225 627 243 750)
  (158 405 551 439 803 149 737 773 220 910 341 798 536 209 753 199 273 141 617 122)
  (457 176 371 757 456 192 304 803 256 627 695 762 232 400 755 520 706 926 200 382)
  (566 92 846 448 743 796 54 210 442 623 423 247 52 262 386 747 337 514 145 635)
  (729 403 105 108 514 434 752 244 175 291 147 78 520 708 843 494 409 392 744 572)
  (799 76 122 195 129 298 242 547 563 909 750 438 178 632 514 273 858 397 708 151)
  (482 119 106 800 341 112 804 846 436 566 890 925 515 886 763 236 793 420 908 133)
  (665 335 739 444 989 246 461 57 684 443 842 146 80 372 152 133 306 628 206 753)
  ...
  ...)
 ```

Adding this into solution function:

```clojure
(defn solution []
  (let [input (read-input)
        rules (build-rules input)
        nearby-tickets (parse-nearby-tickets input)]
    ))
```

# Removing invalid tickets

A ticket is invalid if it contains a value in a field that can't be in any of the rules. This means we just need a function which takes the set of rules and a ticket and returns true or false for ticket validity.


Lets get all the valid boundaries into one flat sequence:

```clojure
(mapcat #(drop 1 %) [["departure location" [5 15] [40 45]]
                     ["departure station" [1 13] [30 35]]
                     ["departure platform" [2 6] [8 11]]
                     ["departure track" [21 22] [88 89]]])
;=> ([5 15] [40 45] [1 13] [30 35] [2 6] [8 11] [21 22] [88 89])
```
First a function that determines if a single ticket entry is valid.

```
(defn valid-ticket-entry? [ranges n]
  (not-any? (fn [[a b]]
              (<= a n b)) ranges))
```

This is just checking that a single entry in a ticket is within each of the rule boundaries.

Now a function that will call that function for each value in a ticket to determine if the ticket overall is valid:

```clojure
(defn valid-ticket? [valid-ranges ticket]
  (not-any? (partial valid-ticket-entry? valid-ranges) ticket))
```

Can plug this into the final solution to filter the nearby tickets into valid tickets:

```clojure
(defn solution []
  (let [input (read-input)
        rules (build-rules input)
        rule-boundaries (mapcat #(drop 1 %) rules)
        nearby-tickets (->> (parse-nearby-tickets input)
                            (filter (partial valid-ticket? rule-boundaries)))]
    ))
```

Now all the parsing and filtering is out of the way, we can proceed to the actual problem of determing which fields are which in the ticket!

# Determining Ticket Fields

At this point our data is in the following form:

A rule looks like this:

```clojure
["departure location" [5 15] [40 45]]
```
And a ticket looks like this

```clojure
(279 705 188 357 892 488 741 247 572 176 760 306 410 861 507 906 179 501 808 245)
```

We have a collection of rules and a collection of tickets.

Going back to the original example with the following rules and tickets:

rules:
```
class: 0-1 or 4-19
row: 0-5 or 8-19
seat: 0-13 or 16-19
```

valid tickets:
```                                                                                                      
3,9,18                                                                                                   
15,1,5                                                                                                   
5,14,9   
```

```
tickets  |   3  |   9  |  18   |                                                                         
         |  15  |   1  |   5   |                                                                         
         |   5  |  14  |   9   |                                                                         
         |---------------------|                                                                         
possible | row | row   | row   |                                                                         
fields   |     | class | class |                                                                         
         |     |       | seat  |  
```

The first item in the first ticket is 3, this is a valid entry for "row" (3 is between 0 and 5), "seat" as 3 is between 0 and 13.
The first item in the second ticket is 15, this is a valid entry for "class" (15 is between 4 and 19), "row" (15 is between 8 and 19) but not "seat"
the first item in the third ticket is 5, this is a valid entry for "row", "class" and "seat"

The only field that is common to all 3 is "row", so the first value in all the tickets can only be "row"

We can apply this same logic to each value in each ticket column, over all the tickets, to get a list of possible fields that are possible for each column.

The first problem is the tickets needs transposed. Working with columns is too tricky, so we need to transpose the tickets so rows become columns and columns become rows.

e.g, if we had the tickets

```
[[1 2 3]
 [4 5 6]
 [7 8 9]]
```
We want
```
[[1 4 7]
 [2 5 8]
 [3 6 9]]
```

You can do this with `(apply map vector coll)`:

```clojure
(let [tickets [[1 2 3]
               [4 5 6]
               [7 8 9]]]
  (apply map vector tickets))
=> ([1 4 7] [2 5 8] [3 6 9])
```

Now the tickets are transposed, we want to build a map of ticket locations and possible fields. e.g.

```clojure
{0 ["row"]
 1 ["row" "class"]
 2 ["row" "class" "seat"]}
```

This says that ticket location 0 can be "row", ticket location 1 can be "row" or "class", ticket location 2 can be "row", "class" or "seat"

# Final Solution

```clojure
(defn read-input []
  (->> (slurp "resources/2020/day16")
       (str/split-lines)))

(defn build-rule [[rule-name r1 r2]]
  (letfn [(parse-range [r]
            (let [[s e] (->> (str/split r #"-")
                             (map #(Integer/parseInt %)))]
              [s e]))]
    [rule-name (parse-range r1) (parse-range r2)]))
    

(defn build-rules [input]
  (->> input
       (take 20)
       (map (fn [rule] (rest (re-find #"(.+): (\d+-\d+) or (\d+-\d+)" rule))))
       (map build-rule)))

(defn parse-nearby-tickets [input]
  (->> input
       (drop 25)
       (map #(->> (str/split % #",")
                  (map (fn [n] (Integer/parseInt n)))))))

(defn valid-ticket-entry? [ranges n]
  (not-any? (fn [[a b]]
              (<= a n b)) ranges))

(defn valid-ticket? [valid-ranges ticket]
  (not-any? (partial valid-ticket-entry? valid-ranges) ticket))
  
(defn solution []
  (let [input (read-input)
        rules (build-rules input)
        rule-boundaries (mapcat #(drop 1 %) rules)
        nearby-tickets (->> (parse-nearby-tickets input)
                            (filter (partial valid-ticket? rule-boundaries))
                            (apply map vector))]
    ))
```
