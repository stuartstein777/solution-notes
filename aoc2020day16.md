The problem for Advent of Code Day 16 is we are given a ticket with fields we can't understand and values for those fields:

e.g, An example ticket:

```
.--------------------------------------------------------.
| ????: 101    ?????: 102   ??????????: 103     ???: 104 |
|                                                        |
| ??: 301  ??: 302             ???????: 303      ??????? |
| ??: 401  ??: 402           ???? ????: 403    ????????? |
'--------------------------------------------------------'
```

And some rules for the fields on the ticket:

```
class: 0-1 or 4-19
row: 0-5 or 8-19
seat: 0-13 or 16-19
```

We also get given our ticket, and some nearby tickets:

```
your ticket:                                                                                             
11,12,13                                                                                                 
                                                                                                         
nearby tickets:                                                                                          
3,9,18                                                                                                   
15,1,5                                                                                                   
6,9,87                                                                                                   
5,14,9                                                                                                   
11,3,22  
```

We have to filter out invalid tickets, then use the remaining tickets to determine which fields is which in our ticket based on the rules.

For the example input the invalid tickets would be:                                                      

```
6,9,87                                                                                                   
11,3,22                                                                                                  
```                                                                                                      
That leaves:                                                                                             

```                                                                                                      
3,9,18                                                                                                   
15,1,5                                                                                                   
5,14,9   
```

From this we can determine the fields:

```
tickets  |   3  |   9  |  18   |                                                                         
         |  15  |   1  |   5   |                                                                         
         |   5  |  14  |   9   |                                                                         
         |---------------------|                                                                         
possible | row | row   | row   |                                                                         
fields   |     | class | class |                                                                         
         |     |       | seat  |  
```

So the first value in a ticket has to be "row"
The second value in a ticket has to be "class"
The third value in a ticket has to be "seat"

This logic needs implementing for the much larger actual puzzle input.    

# Filtering out invalid tickets

This is just parsing the ranges and finding tickets that contain fields which can't be placed into any of the ranges.   

## Parsing the rules from the input

The first 20 lines of the input contain the rules.

```clojure
(defn read-input []                                                                                      
   (->> (slurp "resources/2020/day16")                                                                   
        (str/split-lines)))    

```

An example rule from the input:

"departure location: 26-715 or 727-972"

This can be regex'd out as `rule name`, `range1`, `range2`:

```clojure
(rest (re-find #"(.+): (\d+-\d+) or (\d+-\d+)" "departure location: 26-715 or 727-972"))
;=> ("departure location" "26-715" "727-972") 
```

So read 20 lines from the input and map this over them:

```clojure
(->> (read-input)
     (take 20)
     (map (fn [rule] (rest (re-find #"(.+): (\d+-\d+) or (\d+-\d+)" rule)))))
```
produces:

```
(("departure location" "26-715" "727-972")
 ("departure station" "45-164" "175-960")
 ("departure platform" "43-247" "270-972")
 ("departure track" "25-306" "330-949")
 ...
 ...
 ("zone" "34-521" "534-971"))
```
Now a function to parse those into integers:

```clojure
;input ("departure location" "26-715" "727-972")
;output ["departure location" [26 715] [727 972]]
(defn build-rule [[desc r1 r2]]
  (letfn [(parse-range [r]
            (let [[s e] (->> (str/split r #"-")
                             (map #(Integer/parseInt %)))]
              [s e]))]
    [desc (parse-range r1) (parse-range r2)]))
```

This function destructures the rule that was passed in, that rule being a collection with 3 items, into `rule-name`, `r1` and `r2`. It then defines a local function called `parse-range` and returns the rule as a vector of rule-name, rule1, rule2.

```clojure
(build-rule '("departure location" "26-715" "727-972"))
=> ["departure location" [26 715] [727 972]]
```

Adding this into the main parsing code:

```clojure
(->> (read-input)
     (take 20)
     (map (fn [rule] (rest (re-find #"(.+): (\d+-\d+) or (\d+-\d+)" rule))))
     (map build-rule))
```
